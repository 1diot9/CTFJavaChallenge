package org.h2.fulltext;

import ch.qos.logback.core.joran.JoranConstants;
import java.io.IOException;
import java.io.Reader;
import java.io.StreamTokenizer;
import java.sql.Clob;
import java.sql.Connection;
import java.sql.DatabaseMetaData;
import java.sql.PreparedStatement;
import java.sql.ResultSet;
import java.sql.SQLException;
import java.sql.Statement;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collections;
import java.util.HashSet;
import java.util.Iterator;
import java.util.Set;
import java.util.StringTokenizer;
import java.util.UUID;
import org.apache.tomcat.util.bcel.Const;
import org.h2.api.Trigger;
import org.h2.command.Parser;
import org.h2.engine.SessionLocal;
import org.h2.expression.Expression;
import org.h2.expression.ExpressionColumn;
import org.h2.expression.ValueExpression;
import org.h2.expression.condition.Comparison;
import org.h2.expression.condition.ConditionAndOr;
import org.h2.jdbc.JdbcConnection;
import org.h2.message.DbException;
import org.h2.store.LobStorageFrontend;
import org.h2.tools.SimpleResultSet;
import org.h2.util.IOUtils;
import org.h2.util.StringUtils;
import org.h2.util.Utils;

/* loaded from: agent.jar:BOOT-INF/lib/h2-2.2.224.jar:org/h2/fulltext/FullText.class */
public class FullText {
    private static final String FIELD_SCHEMA = "SCHEMA";
    private static final String FIELD_TABLE = "TABLE";
    private static final String FIELD_COLUMNS = "COLUMNS";
    private static final String FIELD_KEYS = "KEYS";
    private static final String FIELD_SCORE = "SCORE";
    private static final String TRIGGER_PREFIX = "FT_";
    private static final String SCHEMA = "FT";
    private static final String SELECT_MAP_BY_WORD_ID = "SELECT ROWID FROM FT.MAP WHERE WORDID=?";
    private static final String SELECT_ROW_BY_ID = "SELECT `KEY`, INDEXID FROM FT.ROWS WHERE ID=?";
    private static final String FIELD_QUERY = "QUERY";

    public static void init(Connection connection) throws SQLException {
        Statement createStatement = connection.createStatement();
        createStatement.execute("CREATE SCHEMA IF NOT EXISTS FT");
        createStatement.execute("CREATE TABLE IF NOT EXISTS FT.INDEXES(ID INT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY, SCHEMA VARCHAR, `TABLE` VARCHAR, COLUMNS VARCHAR, UNIQUE(SCHEMA, `TABLE`))");
        createStatement.execute("CREATE TABLE IF NOT EXISTS FT.WORDS(ID INT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY, NAME VARCHAR, UNIQUE(NAME))");
        createStatement.execute("CREATE TABLE IF NOT EXISTS FT.ROWS(ID BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY, HASH INT, INDEXID INT, `KEY` VARCHAR, UNIQUE(HASH, INDEXID, `KEY`))");
        createStatement.execute("CREATE TABLE IF NOT EXISTS FT.MAP(ROWID INT, WORDID INT, PRIMARY KEY(WORDID, ROWID))");
        createStatement.execute("CREATE TABLE IF NOT EXISTS FT.IGNORELIST(LIST VARCHAR)");
        createStatement.execute("CREATE TABLE IF NOT EXISTS FT.SETTINGS(`KEY` VARCHAR PRIMARY KEY, `VALUE` VARCHAR)");
        String name = FullText.class.getName();
        createStatement.execute("CREATE ALIAS IF NOT EXISTS FT_CREATE_INDEX FOR '" + name + ".createIndex'");
        createStatement.execute("CREATE ALIAS IF NOT EXISTS FT_DROP_INDEX FOR '" + name + ".dropIndex'");
        createStatement.execute("CREATE ALIAS IF NOT EXISTS FT_SEARCH FOR '" + name + ".search'");
        createStatement.execute("CREATE ALIAS IF NOT EXISTS FT_SEARCH_DATA FOR '" + name + ".searchData'");
        createStatement.execute("CREATE ALIAS IF NOT EXISTS FT_REINDEX FOR '" + name + ".reindex'");
        createStatement.execute("CREATE ALIAS IF NOT EXISTS FT_DROP_ALL FOR '" + name + ".dropAll'");
        FullTextSettings fullTextSettings = FullTextSettings.getInstance(connection);
        ResultSet executeQuery = createStatement.executeQuery("SELECT * FROM FT.IGNORELIST");
        while (executeQuery.next()) {
            setIgnoreList(fullTextSettings, executeQuery.getString(1));
        }
        ResultSet executeQuery2 = createStatement.executeQuery("SELECT * FROM FT.SETTINGS");
        while (executeQuery2.next()) {
            if ("whitespaceChars".equals(executeQuery2.getString(1))) {
                fullTextSettings.setWhitespaceChars(executeQuery2.getString(2));
            }
        }
        ResultSet executeQuery3 = createStatement.executeQuery("SELECT * FROM FT.WORDS");
        while (executeQuery3.next()) {
            String string = executeQuery3.getString("NAME");
            int i = executeQuery3.getInt("ID");
            String convertWord = fullTextSettings.convertWord(string);
            if (convertWord != null) {
                fullTextSettings.addWord(convertWord, Integer.valueOf(i));
            }
        }
        fullTextSettings.setInitialized(true);
    }

    public static void createIndex(Connection connection, String str, String str2, String str3) throws SQLException {
        init(connection);
        PreparedStatement prepareStatement = connection.prepareStatement("INSERT INTO FT.INDEXES(SCHEMA, `TABLE`, COLUMNS) VALUES(?, ?, ?)");
        prepareStatement.setString(1, str);
        prepareStatement.setString(2, str2);
        prepareStatement.setString(3, str3);
        prepareStatement.execute();
        createTrigger(connection, str, str2);
        indexExistingRows(connection, str, str2);
    }

    public static void reindex(Connection connection) throws SQLException {
        init(connection);
        removeAllTriggers(connection, TRIGGER_PREFIX);
        FullTextSettings.getInstance(connection).clearWordList();
        Statement createStatement = connection.createStatement();
        createStatement.execute("TRUNCATE TABLE FT.WORDS");
        createStatement.execute("TRUNCATE TABLE FT.ROWS");
        createStatement.execute("TRUNCATE TABLE FT.MAP");
        ResultSet executeQuery = createStatement.executeQuery("SELECT * FROM FT.INDEXES");
        while (executeQuery.next()) {
            String string = executeQuery.getString(FIELD_SCHEMA);
            String string2 = executeQuery.getString(FIELD_TABLE);
            createTrigger(connection, string, string2);
            indexExistingRows(connection, string, string2);
        }
    }

    public static void dropIndex(Connection connection, String str, String str2) throws SQLException {
        init(connection);
        PreparedStatement prepareStatement = connection.prepareStatement("SELECT ID FROM FT.INDEXES WHERE SCHEMA=? AND `TABLE`=?");
        prepareStatement.setString(1, str);
        prepareStatement.setString(2, str2);
        ResultSet executeQuery = prepareStatement.executeQuery();
        if (!executeQuery.next()) {
            return;
        }
        int i = executeQuery.getInt(1);
        PreparedStatement prepareStatement2 = connection.prepareStatement("DELETE FROM FT.INDEXES WHERE ID=?");
        prepareStatement2.setInt(1, i);
        prepareStatement2.execute();
        createOrDropTrigger(connection, str, str2, false);
        PreparedStatement prepareStatement3 = connection.prepareStatement("DELETE FROM FT.ROWS WHERE INDEXID=? AND ROWNUM<10000");
        do {
            prepareStatement3.setInt(1, i);
        } while (prepareStatement3.executeUpdate() != 0);
        do {
        } while (connection.prepareStatement("DELETE FROM FT.MAP WHERE NOT EXISTS (SELECT * FROM FT.ROWS R WHERE R.ID=ROWID) AND ROWID<10000").executeUpdate() != 0);
    }

    public static void dropAll(Connection connection) throws SQLException {
        init(connection);
        connection.createStatement().execute("DROP SCHEMA IF EXISTS FT CASCADE");
        removeAllTriggers(connection, TRIGGER_PREFIX);
        FullTextSettings fullTextSettings = FullTextSettings.getInstance(connection);
        fullTextSettings.removeAllIndexes();
        fullTextSettings.clearIgnored();
        fullTextSettings.clearWordList();
    }

    public static ResultSet search(Connection connection, String str, int i, int i2) throws SQLException {
        try {
            return search(connection, str, i, i2, false);
        } catch (DbException e) {
            throw DbException.toSQLException(e);
        }
    }

    public static ResultSet searchData(Connection connection, String str, int i, int i2) throws SQLException {
        try {
            return search(connection, str, i, i2, true);
        } catch (DbException e) {
            throw DbException.toSQLException(e);
        }
    }

    public static void setIgnoreList(Connection connection, String str) throws SQLException {
        try {
            init(connection);
            setIgnoreList(FullTextSettings.getInstance(connection), str);
            connection.createStatement().execute("TRUNCATE TABLE FT.IGNORELIST");
            PreparedStatement prepareStatement = connection.prepareStatement("INSERT INTO FT.IGNORELIST VALUES(?)");
            prepareStatement.setString(1, str);
            prepareStatement.execute();
        } catch (DbException e) {
            throw DbException.toSQLException(e);
        }
    }

    public static void setWhitespaceChars(Connection connection, String str) throws SQLException {
        try {
            init(connection);
            FullTextSettings.getInstance(connection).setWhitespaceChars(str);
            PreparedStatement prepareStatement = connection.prepareStatement("MERGE INTO FT.SETTINGS VALUES(?, ?)");
            prepareStatement.setString(1, "whitespaceChars");
            prepareStatement.setString(2, str);
            prepareStatement.execute();
        } catch (DbException e) {
            throw DbException.toSQLException(e);
        }
    }

    /* JADX INFO: Access modifiers changed from: protected */
    public static String asString(Object obj, int i) throws SQLException {
        if (obj == null) {
            return JoranConstants.NULL;
        }
        switch (i) {
            case -7:
            case -6:
            case -5:
            case -1:
            case 1:
            case 2:
            case 3:
            case 4:
            case 5:
            case 6:
            case 7:
            case 8:
            case 12:
            case 16:
            case 91:
            case 92:
            case 93:
                return obj.toString();
            case -4:
            case LobStorageFrontend.TABLE_RESULT /* -3 */:
            case -2:
            case 0:
            case 70:
            case 1111:
            case 2000:
            case 2001:
            case 2002:
            case 2003:
            case 2004:
            case 2006:
                throw throwException("Unsupported column data type: " + i);
            case 2005:
                try {
                    if (obj instanceof Clob) {
                        obj = ((Clob) obj).getCharacterStream();
                    }
                    return IOUtils.readStringAndClose((Reader) obj, -1);
                } catch (IOException e) {
                    throw DbException.toSQLException(e);
                }
            default:
                return "";
        }
    }

    /* JADX INFO: Access modifiers changed from: protected */
    public static SimpleResultSet createResultSet(boolean z) {
        SimpleResultSet simpleResultSet = new SimpleResultSet();
        if (z) {
            simpleResultSet.addColumn(FIELD_SCHEMA, 12, 0, 0);
            simpleResultSet.addColumn(FIELD_TABLE, 12, 0, 0);
            simpleResultSet.addColumn(FIELD_COLUMNS, 2003, "VARCHAR ARRAY", 0, 0);
            simpleResultSet.addColumn(FIELD_KEYS, 2003, "VARCHAR ARRAY", 0, 0);
        } else {
            simpleResultSet.addColumn(FIELD_QUERY, 12, 0, 0);
        }
        simpleResultSet.addColumn(FIELD_SCORE, 6, 0, 0);
        return simpleResultSet;
    }

    /* JADX INFO: Access modifiers changed from: protected */
    /* JADX WARN: Type inference failed for: r0v18, types: [java.lang.String[], java.lang.String[][]] */
    public static String[][] parseKey(Connection connection, String str) {
        ArrayList newSmallArrayList = Utils.newSmallArrayList();
        ArrayList newSmallArrayList2 = Utils.newSmallArrayList();
        SessionLocal sessionLocal = (SessionLocal) ((JdbcConnection) connection).getSession();
        addColumnData(sessionLocal, newSmallArrayList, newSmallArrayList2, new Parser(sessionLocal).parseExpression(str));
        return new String[]{(String[]) newSmallArrayList.toArray(new String[0]), (String[]) newSmallArrayList2.toArray(new String[0])};
    }

    /* JADX INFO: Access modifiers changed from: protected */
    public static String quoteSQL(Object obj, int i) throws SQLException {
        if (obj == null) {
            return JoranConstants.NULL;
        }
        switch (i) {
            case -7:
            case -6:
            case -5:
            case 2:
            case 3:
            case 4:
            case 5:
            case 6:
            case 7:
            case 8:
            case 16:
                return obj.toString();
            case -4:
            case LobStorageFrontend.TABLE_RESULT /* -3 */:
            case -2:
                if (obj instanceof UUID) {
                    return "'" + obj + "'";
                }
                byte[] bArr = (byte[]) obj;
                StringBuilder append = new StringBuilder((bArr.length * 2) + 2).append('\'');
                StringUtils.convertBytesToHex(append, bArr).append('\'');
                return append.toString();
            case -1:
            case 1:
            case 12:
            case 91:
            case 92:
            case 93:
                return quoteString(obj.toString());
            case 0:
            case 70:
            case 1111:
            case 2000:
            case 2001:
            case 2002:
            case 2003:
            case 2004:
            case 2005:
            case 2006:
                throw throwException("Unsupported key data type: " + i);
            default:
                return "";
        }
    }

    /* JADX INFO: Access modifiers changed from: protected */
    public static void removeAllTriggers(Connection connection, String str) throws SQLException {
        ResultSet executeQuery = connection.createStatement().executeQuery("SELECT DISTINCT TRIGGER_SCHEMA, TRIGGER_NAME FROM INFORMATION_SCHEMA.TRIGGERS");
        Statement createStatement = connection.createStatement();
        while (executeQuery.next()) {
            String string = executeQuery.getString("TRIGGER_SCHEMA");
            String string2 = executeQuery.getString("TRIGGER_NAME");
            if (string2.startsWith(str)) {
                createStatement.execute("DROP TRIGGER " + (StringUtils.quoteIdentifier(string) + "." + StringUtils.quoteIdentifier(string2)));
            }
        }
    }

    /* JADX INFO: Access modifiers changed from: protected */
    public static void setColumns(int[] iArr, ArrayList<String> arrayList, ArrayList<String> arrayList2) throws SQLException {
        int size = arrayList.size();
        for (int i = 0; i < size; i++) {
            String str = arrayList.get(i);
            int i2 = -1;
            int size2 = arrayList2.size();
            for (int i3 = 0; i2 == -1 && i3 < size2; i3++) {
                if (arrayList2.get(i3).equals(str)) {
                    i2 = i3;
                }
            }
            if (i2 < 0) {
                throw throwException("Column not found: " + str);
            }
            iArr[i] = i2;
        }
    }

    protected static ResultSet search(Connection connection, String str, int i, int i2, boolean z) throws SQLException {
        SimpleResultSet createResultSet = createResultSet(z);
        if (connection.getMetaData().getURL().startsWith("jdbc:columnlist:")) {
            return createResultSet;
        }
        if (str == null || StringUtils.isWhitespaceOrEmpty(str)) {
            return createResultSet;
        }
        FullTextSettings fullTextSettings = FullTextSettings.getInstance(connection);
        if (!fullTextSettings.isInitialized()) {
            init(connection);
        }
        HashSet<String> hashSet = new HashSet();
        addWords(fullTextSettings, hashSet, str);
        HashSet hashSet2 = null;
        PreparedStatement prepare = fullTextSettings.prepare(connection, SELECT_MAP_BY_WORD_ID);
        for (String str2 : hashSet) {
            HashSet hashSet3 = hashSet2;
            hashSet2 = new HashSet();
            Integer wordId = fullTextSettings.getWordId(str2);
            if (wordId != null) {
                prepare.setInt(1, wordId.intValue());
                ResultSet executeQuery = prepare.executeQuery();
                while (executeQuery.next()) {
                    Integer valueOf = Integer.valueOf(executeQuery.getInt(1));
                    if (hashSet3 == null || hashSet3.contains(valueOf)) {
                        hashSet2.add(valueOf);
                    }
                }
            }
        }
        if (hashSet2 == null || hashSet2.isEmpty()) {
            return createResultSet;
        }
        PreparedStatement prepare2 = fullTextSettings.prepare(connection, SELECT_ROW_BY_ID);
        int i3 = 0;
        Iterator it = hashSet2.iterator();
        while (it.hasNext()) {
            prepare2.setInt(1, ((Integer) it.next()).intValue());
            ResultSet executeQuery2 = prepare2.executeQuery();
            if (executeQuery2.next()) {
                if (i2 <= 0) {
                    String string = executeQuery2.getString(1);
                    IndexInfo indexInfo = fullTextSettings.getIndexInfo(executeQuery2.getInt(2));
                    if (z) {
                        String[][] parseKey = parseKey(connection, string);
                        createResultSet.addRow(indexInfo.schema, indexInfo.table, parseKey[0], parseKey[1], Double.valueOf(1.0d));
                    } else {
                        createResultSet.addRow(StringUtils.quoteIdentifier(indexInfo.schema) + "." + StringUtils.quoteIdentifier(indexInfo.table) + " WHERE " + string, Double.valueOf(1.0d));
                    }
                    i3++;
                    if (i > 0 && i3 >= i) {
                        break;
                    }
                } else {
                    i2--;
                }
            }
        }
        return createResultSet;
    }

    private static void addColumnData(SessionLocal sessionLocal, ArrayList<String> arrayList, ArrayList<String> arrayList2, Expression expression) {
        if (expression instanceof ConditionAndOr) {
            ConditionAndOr conditionAndOr = (ConditionAndOr) expression;
            addColumnData(sessionLocal, arrayList, arrayList2, conditionAndOr.getSubexpression(0));
            addColumnData(sessionLocal, arrayList, arrayList2, conditionAndOr.getSubexpression(1));
        } else {
            Comparison comparison = (Comparison) expression;
            arrayList.add(((ExpressionColumn) comparison.getSubexpression(0)).getColumnName(sessionLocal, -1));
            if (expression.getSubexpressionCount() == 1) {
                arrayList2.add(null);
            } else {
                arrayList2.add(((ValueExpression) comparison.getSubexpression(1)).getValue(null).getString());
            }
        }
    }

    protected static void addWords(FullTextSettings fullTextSettings, Set<String> set, Reader reader) {
        String convertWord;
        StreamTokenizer streamTokenizer = new StreamTokenizer(reader);
        streamTokenizer.resetSyntax();
        streamTokenizer.wordChars(33, Const.MAX_ARRAY_DIMENSIONS);
        for (char c : fullTextSettings.getWhitespaceChars().toCharArray()) {
            streamTokenizer.whitespaceChars(c, c);
        }
        while (true) {
            try {
                int nextToken = streamTokenizer.nextToken();
                if (nextToken != -1) {
                    if (nextToken == -3 && (convertWord = fullTextSettings.convertWord(streamTokenizer.sval)) != null) {
                        set.add(convertWord);
                    }
                } else {
                    return;
                }
            } catch (IOException e) {
                throw DbException.convertIOException(e, "Tokenizer error");
            }
        }
    }

    protected static void addWords(FullTextSettings fullTextSettings, Set<String> set, String str) {
        StringTokenizer stringTokenizer = new StringTokenizer(str, fullTextSettings.getWhitespaceChars());
        while (stringTokenizer.hasMoreTokens()) {
            String convertWord = fullTextSettings.convertWord(stringTokenizer.nextToken());
            if (convertWord != null) {
                set.add(convertWord);
            }
        }
    }

    private static void createTrigger(Connection connection, String str, String str2) throws SQLException {
        createOrDropTrigger(connection, str, str2, true);
    }

    private static void createOrDropTrigger(Connection connection, String str, String str2, boolean z) throws SQLException {
        Statement createStatement = connection.createStatement();
        Throwable th = null;
        try {
            String str3 = StringUtils.quoteIdentifier(str) + "." + StringUtils.quoteIdentifier(TRIGGER_PREFIX + str2);
            createStatement.execute("DROP TRIGGER IF EXISTS " + str3);
            if (z) {
                StringBuilder sb = new StringBuilder("CREATE TRIGGER IF NOT EXISTS ");
                sb.append(str3).append(" AFTER INSERT, UPDATE, DELETE");
                sb.append(" ON ");
                StringUtils.quoteIdentifier(sb, str).append('.');
                StringUtils.quoteIdentifier(sb, str2).append(" FOR EACH ROW CALL \"").append(FullTextTrigger.class.getName()).append('\"');
                createStatement.execute(sb.toString());
            }
            if (createStatement != null) {
                if (0 != 0) {
                    try {
                        createStatement.close();
                        return;
                    } catch (Throwable th2) {
                        th.addSuppressed(th2);
                        return;
                    }
                }
                createStatement.close();
            }
        } catch (Throwable th3) {
            if (createStatement != null) {
                if (0 != 0) {
                    try {
                        createStatement.close();
                    } catch (Throwable th4) {
                        th.addSuppressed(th4);
                    }
                } else {
                    createStatement.close();
                }
            }
            throw th3;
        }
    }

    private static void indexExistingRows(Connection connection, String str, String str2) throws SQLException {
        FullTextTrigger fullTextTrigger = new FullTextTrigger();
        fullTextTrigger.init(connection, str, null, str2, false, 1);
        ResultSet executeQuery = connection.createStatement().executeQuery("SELECT * FROM " + StringUtils.quoteIdentifier(str) + "." + StringUtils.quoteIdentifier(str2));
        int columnCount = executeQuery.getMetaData().getColumnCount();
        while (executeQuery.next()) {
            Object[] objArr = new Object[columnCount];
            for (int i = 0; i < columnCount; i++) {
                objArr[i] = executeQuery.getObject(i + 1);
            }
            fullTextTrigger.fire(connection, null, objArr);
        }
    }

    private static String quoteString(String str) {
        if (str.indexOf(39) < 0) {
            return "'" + str + "'";
        }
        int length = str.length();
        StringBuilder sb = new StringBuilder(length + 2);
        sb.append('\'');
        for (int i = 0; i < length; i++) {
            char charAt = str.charAt(i);
            if (charAt == '\'') {
                sb.append(charAt);
            }
            sb.append(charAt);
        }
        sb.append('\'');
        return sb.toString();
    }

    private static void setIgnoreList(FullTextSettings fullTextSettings, String str) {
        fullTextSettings.addIgnored(Arrays.asList(StringUtils.arraySplit(str, ',', true)));
    }

    /* JADX INFO: Access modifiers changed from: protected */
    public static boolean hasChanged(Object[] objArr, Object[] objArr2, int[] iArr) {
        for (int i : iArr) {
            Object obj = objArr[i];
            Object obj2 = objArr2[i];
            if (obj == null) {
                if (obj2 != null) {
                    return true;
                }
            } else if (!obj.equals(obj2)) {
                return true;
            }
        }
        return false;
    }

    /* loaded from: agent.jar:BOOT-INF/lib/h2-2.2.224.jar:org/h2/fulltext/FullText$FullTextTrigger.class */
    public static final class FullTextTrigger implements Trigger {
        private FullTextSettings setting;
        private IndexInfo index;
        private int[] columnTypes;
        private static final int INSERT_WORD = 0;
        private static final int INSERT_ROW = 1;
        private static final int INSERT_MAP = 2;
        private static final int DELETE_ROW = 3;
        private static final int DELETE_MAP = 4;
        private static final int SELECT_ROW = 5;
        private static final String[] SQL = {"MERGE INTO FT.WORDS(NAME) KEY(NAME) VALUES(?)", "INSERT INTO FT.ROWS(HASH, INDEXID, `KEY`) VALUES(?, ?, ?)", "INSERT INTO FT.MAP(ROWID, WORDID) VALUES(?, ?)", "DELETE FROM FT.ROWS WHERE HASH=? AND INDEXID=? AND `KEY`=?", "DELETE FROM FT.MAP WHERE ROWID=? AND WORDID=?", "SELECT ID FROM FT.ROWS WHERE HASH=? AND INDEXID=? AND `KEY`=?"};

        @Override // org.h2.api.Trigger
        public void init(Connection connection, String str, String str2, String str3, boolean z, int i) throws SQLException {
            this.setting = FullTextSettings.getInstance(connection);
            if (!this.setting.isInitialized()) {
                FullText.init(connection);
            }
            ArrayList newSmallArrayList = Utils.newSmallArrayList();
            DatabaseMetaData metaData = connection.getMetaData();
            ResultSet columns = metaData.getColumns(null, StringUtils.escapeMetaDataPattern(str), StringUtils.escapeMetaDataPattern(str3), null);
            ArrayList newSmallArrayList2 = Utils.newSmallArrayList();
            while (columns.next()) {
                newSmallArrayList2.add(columns.getString("COLUMN_NAME"));
            }
            this.columnTypes = new int[newSmallArrayList2.size()];
            this.index = new IndexInfo();
            this.index.schema = str;
            this.index.table = str3;
            this.index.columns = (String[]) newSmallArrayList2.toArray(new String[0]);
            ResultSet columns2 = metaData.getColumns(null, StringUtils.escapeMetaDataPattern(str), StringUtils.escapeMetaDataPattern(str3), null);
            int i2 = 0;
            while (columns2.next()) {
                this.columnTypes[i2] = columns2.getInt("DATA_TYPE");
                i2++;
            }
            if (newSmallArrayList.isEmpty()) {
                ResultSet primaryKeys = metaData.getPrimaryKeys(null, StringUtils.escapeMetaDataPattern(str), str3);
                while (primaryKeys.next()) {
                    newSmallArrayList.add(primaryKeys.getString("COLUMN_NAME"));
                }
            }
            if (newSmallArrayList.isEmpty()) {
                throw FullText.throwException("No primary key for table " + str3);
            }
            ArrayList newSmallArrayList3 = Utils.newSmallArrayList();
            PreparedStatement prepareStatement = connection.prepareStatement("SELECT ID, COLUMNS FROM FT.INDEXES WHERE SCHEMA=? AND `TABLE`=?");
            prepareStatement.setString(1, str);
            prepareStatement.setString(2, str3);
            ResultSet executeQuery = prepareStatement.executeQuery();
            if (executeQuery.next()) {
                this.index.id = executeQuery.getInt(1);
                String string = executeQuery.getString(2);
                if (string != null) {
                    Collections.addAll(newSmallArrayList3, StringUtils.arraySplit(string, ',', true));
                }
            }
            if (newSmallArrayList3.isEmpty()) {
                newSmallArrayList3.addAll(newSmallArrayList2);
            }
            this.index.keys = new int[newSmallArrayList.size()];
            FullText.setColumns(this.index.keys, newSmallArrayList, newSmallArrayList2);
            this.index.indexColumns = new int[newSmallArrayList3.size()];
            FullText.setColumns(this.index.indexColumns, newSmallArrayList3, newSmallArrayList2);
            this.setting.addIndexInfo(this.index);
        }

        @Override // org.h2.api.Trigger
        public void fire(Connection connection, Object[] objArr, Object[] objArr2) throws SQLException {
            if (objArr != null) {
                if (objArr2 != null) {
                    if (FullText.hasChanged(objArr, objArr2, this.index.indexColumns)) {
                        delete(connection, objArr);
                        insert(connection, objArr2);
                        return;
                    }
                    return;
                }
                delete(connection, objArr);
                return;
            }
            if (objArr2 != null) {
                insert(connection, objArr2);
            }
        }

        @Override // org.h2.api.Trigger
        public void close() {
            this.setting.removeIndexInfo(this.index);
        }

        @Override // org.h2.api.Trigger
        public void remove() {
            this.setting.removeIndexInfo(this.index);
        }

        private void insert(Connection connection, Object[] objArr) throws SQLException {
            PreparedStatement preparedStatement = null;
            PreparedStatement preparedStatement2 = null;
            try {
                String key = getKey(objArr);
                int hashCode = key.hashCode();
                preparedStatement = getStatement(connection, 1);
                preparedStatement.setInt(1, hashCode);
                preparedStatement.setInt(2, this.index.id);
                preparedStatement.setString(3, key);
                preparedStatement.execute();
                ResultSet generatedKeys = preparedStatement.getGeneratedKeys();
                generatedKeys.next();
                int i = generatedKeys.getInt(1);
                preparedStatement2 = getStatement(connection, 2);
                preparedStatement2.setInt(1, i);
                for (int i2 : getWordIds(connection, objArr)) {
                    preparedStatement2.setInt(2, i2);
                    preparedStatement2.execute();
                }
                IOUtils.closeSilently(preparedStatement);
                IOUtils.closeSilently(preparedStatement2);
            } catch (Throwable th) {
                IOUtils.closeSilently(preparedStatement);
                IOUtils.closeSilently(preparedStatement2);
                throw th;
            }
        }

        private void delete(Connection connection, Object[] objArr) throws SQLException {
            PreparedStatement preparedStatement = null;
            PreparedStatement preparedStatement2 = null;
            PreparedStatement preparedStatement3 = null;
            try {
                String key = getKey(objArr);
                int hashCode = key.hashCode();
                preparedStatement = getStatement(connection, 5);
                preparedStatement.setInt(1, hashCode);
                preparedStatement.setInt(2, this.index.id);
                preparedStatement.setString(3, key);
                ResultSet executeQuery = preparedStatement.executeQuery();
                preparedStatement2 = getStatement(connection, 4);
                preparedStatement3 = getStatement(connection, 3);
                if (executeQuery.next()) {
                    preparedStatement2.setInt(1, executeQuery.getInt(1));
                    for (int i : getWordIds(connection, objArr)) {
                        preparedStatement2.setInt(2, i);
                        preparedStatement2.executeUpdate();
                    }
                    preparedStatement3.setInt(1, hashCode);
                    preparedStatement3.setInt(2, this.index.id);
                    preparedStatement3.setString(3, key);
                    preparedStatement3.executeUpdate();
                }
                IOUtils.closeSilently(preparedStatement);
                IOUtils.closeSilently(preparedStatement2);
                IOUtils.closeSilently(preparedStatement3);
            } catch (Throwable th) {
                IOUtils.closeSilently(preparedStatement);
                IOUtils.closeSilently(preparedStatement2);
                IOUtils.closeSilently(preparedStatement3);
                throw th;
            }
        }

        private int[] getWordIds(Connection connection, Object[] objArr) throws SQLException {
            Integer num;
            int i;
            Reader characterStream;
            HashSet hashSet = new HashSet();
            for (int i2 : this.index.indexColumns) {
                int i3 = this.columnTypes[i2];
                Object obj = objArr[i2];
                if (i3 == 2005 && obj != null) {
                    if (obj instanceof Reader) {
                        characterStream = (Reader) obj;
                    } else {
                        characterStream = ((Clob) obj).getCharacterStream();
                    }
                    FullText.addWords(this.setting, hashSet, characterStream);
                } else {
                    FullText.addWords(this.setting, hashSet, FullText.asString(obj, i3));
                }
            }
            PreparedStatement preparedStatement = null;
            try {
                preparedStatement = getStatement(connection, 0);
                int[] iArr = new int[hashSet.size()];
                int i4 = 0;
                Iterator it = hashSet.iterator();
                while (it.hasNext()) {
                    String str = (String) it.next();
                    while (true) {
                        Integer wordId = this.setting.getWordId(str);
                        num = wordId;
                        if (wordId == null) {
                            preparedStatement.setString(1, str);
                            preparedStatement.execute();
                            ResultSet generatedKeys = preparedStatement.getGeneratedKeys();
                            if (generatedKeys.next() && (i = generatedKeys.getInt(1)) != 0) {
                                this.setting.addWord(str, Integer.valueOf(i));
                                num = Integer.valueOf(i);
                                break;
                            }
                        }
                    }
                    int i5 = i4;
                    i4++;
                    iArr[i5] = num.intValue();
                }
                Arrays.sort(iArr);
                IOUtils.closeSilently(preparedStatement);
                return iArr;
            } catch (Throwable th) {
                IOUtils.closeSilently(preparedStatement);
                throw th;
            }
        }

        private String getKey(Object[] objArr) throws SQLException {
            StringBuilder sb = new StringBuilder();
            int[] iArr = this.index.keys;
            int length = iArr.length;
            for (int i = 0; i < length; i++) {
                if (i > 0) {
                    sb.append(" AND ");
                }
                int i2 = iArr[i];
                StringUtils.quoteIdentifier(sb, this.index.columns[i2]);
                Object obj = objArr[i2];
                if (obj == null) {
                    sb.append(" IS NULL");
                } else {
                    sb.append('=').append(FullText.quoteSQL(obj, this.columnTypes[i2]));
                }
            }
            return sb.toString();
        }

        private static PreparedStatement getStatement(Connection connection, int i) throws SQLException {
            return connection.prepareStatement(SQL[i], 1);
        }
    }

    public static void closeAll() {
        FullTextSettings.closeAll();
    }

    /* JADX INFO: Access modifiers changed from: protected */
    public static SQLException throwException(String str) throws SQLException {
        throw new SQLException(str, "FULLTEXT");
    }
}
